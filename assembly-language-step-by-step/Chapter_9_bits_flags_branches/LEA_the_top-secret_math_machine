One of the oddest instructions, and in some respects the most wonderful instruction, in the x86 architecture is 'LEA', Load Effective Address. 
On the surface, what it does is simple: It calculates an effective address given between the brackets of its source operand, and loads the address into any 32-bit general-purpose register given as its destination operand. 
In order to look up the item at index 6, it has to first calculate the effective address of the item at index 6. 
This address is then used to access memeory. 

What if you'd like to save that address in a register to use it later?
That's what 'LEA' does. 
Here's 'LEA' in action: 

	lea edx, [ScaleValues+ecx*4]

What happends here is that the CPU calculates the effective address given inside the brackest, and leads that address into the EBX register. 
Keep in mind that the brackets, and leads that addresss into the EBX register. 
Keep in mind that the individual entries in a table do not have labels and thus cannot be referenced directly. 
'LEA' enables you to calculate the effective address in a register. 
In itself this is very useful, but 'LEA' also has an "Off-label" purpose: doing fast math without shifts, adds, or pokey 'MUL'. 
If you remember, there is a calculation in the hexdump1 program that multiplies by three using a shift and an add: 

	mov edx, ecx		; Copy the character counter inot edx

	shl edx, 1		; Multiply pointer by 2 using left shift

	add edx, ecx		; Complete the multiplication X3

The preceding works, but look at what we can use that does not exactlythe same thing:

	mov edx, ecx		; Copy the character counter into edx

	lea edx, [edx*2+edx]	; Multiply edx X 3


Not only is this virtually always faster than shifts combined with adds, it's also cleaner from your source code what sort of caluclation is actually being done.
The fact that what ends up in EDX may not in fact be the legal address of anything is unimportant. 
LEA does not try to reference the address it calculates. 
It does the math on the stuff instide the brackets and drops it  into the destination operand. 
Memory is not touched, and the flags are not affected. 

Of course, you're limited to what calculations can be done on effective addresses; but right off the top, you can multiply any GP register by 2, 3, 4, 5, 8, and 9, while tossing in a constant. 
It's not arbitrary math, but multiplying by 2, 3, 4, 5, 8, and 9 comes up regularly in assemly work, and you can combine 'LEA' with shifts and adds to do more complex math. 
You can also use multiple 'LEA' instructions in a row. 
Two consecutive 'LEA' instructions can multiply a value by 10, which is useful indeed: 

	lea ebx, [ebx*2]		; Multiply edx X 2

	lea ebx, [ebx*4+ebx]		; Multiply ebx X 5 for a total of X 10

This is an expert use of 'LEA'.
Before throwing five on six instructions into the pot to cook up a particular multiplication, see if two or three 'LEA's can do it instead. 
'LEA' does its work in one machine cycle, and x86 math doesn't get any faster than that!

Most of the time, you hand values to machine instructions through one or two operands placed right there on the line beside the mnemonic. 
This is good, because when yousay "MOV" "EAX" "EBX" you know precisely what's moving, where it comes from, and where its going. 
Alas, that isn't always the case. 
Some instructions act on registers on even memory locations that are not stated in the list of operands. 
These instructions do in fact have operands, but they represent assumptions made by the instrucion. 
Such opernads are called "implicit operands", and they do not change and cannot be changed. 

The best examples of implicit operands in the x86 instruction set are the multiplication and division instructions. 
Excluding the instructions in the dedicated math processors the x86 instruction set has two sets of multiply and divide instructions. 
On set, "MUL" and "DIV", handle unsigned calculations. 
The other, "IMUL" and "IDIV", handle signed caluclations. 

Among the basic math operations, however, multiplication has a special problem: it generates output values that are often "hugely" larger than the input values. 
This makes it impossible to follow the convertional pattern in x86 instruction operands, whereby they value generated by an instruction goes into the destination operand. 

Consider a 32-bit multiply operation. 
The largest unsigned value that will fit in a 32 bit register is 4,294,967,295 (i'm using a round down for now on you will get it trust me hacking only needs exact numbers like this). 
Multiply that even by two and you've got a 33-bit product, which will no longer fit in any 32-bit register. 
This problem has plagued the x86 architecture since the beginning. 
When the x86 was a 16-bit values, which can easily overflow a 16-bit register. 

Intel engineers solved it by using two registers to hold the product. 
The largest product of two binary numbers can be expressed in no more than twice the number of bits required by the largesr factor (Its crazy but ya its true look at discrete math with modulo function operations)

Which brings us to the "MUL" instruction. 
"MUL" is an odd bird from an operand standpoint: it takes only one operand, which contains one of the factors to be multiplied. 
The other factor is implicit, as is the pair of registers that receives the product of calculation. 
"MUL" thus looks deceptively simple: 
More involved here than just EBX. 
The implicit operands depend on the size of the explicit one. 

The first factor is given in the single explicit operand, which can be a value either in a register or in memory location. 
The second factor is implicit, and always in the "A" general-purpose register appropriate to the size of the first factor. 
if the first factor is an 8-bit value, the second factor is always in the 8-bit register AL. 
If the first factor is a 16-bit value, the second factor is always in the 16-bit register AX, and so on. 

Once the product requires more than 16 bits the "D" register is drafted to hold the high-order portion of the product. 
For eample if you multiply two 16-bits values and the product is 02A456Fh, then register AX will contain 0456Fh, and the Dx register will conatin 02Ah.

Registers often become scarce in assembly work, but even if you're sure that your multiplications always involve small products, you can't use the high-order register for anything else while a "MUL" instruction is executed. 

as useful as it would often be to state the first factor as an immediate value: 

		mul 42
